import org.apache.tools.ant.taskdefs.condition.Os

buildscript {
	repositories {
		jcenter()
	}
	dependencies {
		classpath 'org.yaml:snakeyaml:1.15'
	}
}
//project.afterEvaluate { project.tasks.all { Task t -> t.inputs.file 'build.gradle'; } }

task jobs(type: Exec) {
	group = "Pre-build"
	description = "Processes the jobs collection by removing unused stuff from their frontmatter for privacy"
	afterEvaluate { tasks.build.mustRunAfter jobs }
	afterEvaluate { tasks.serve.mustRunAfter jobs }

	def script = 'sources/jobs/strip-frontmatter.rb'
	def from = 'sources/jobs/'
	def to = '_jobs/'
	inputs.file script
	inputs.dir from
	outputs.dir to
	logging.captureStandardOutput LogLevel.INFO
	commandLine 'ruby', script, from, to
}
task font(type: Exec) {
	group = "Pre-build"
	description = "Regenerate the custom icon font"
	afterEvaluate { tasks.build.mustRunAfter font }
	afterEvaluate { tasks.serve.mustRunAfter font }

	workingDir 'sources/iconfont'
	inputs.file new File(workingDir, 'fontcustom.yml')
	inputs.dir new File(workingDir, 'vectors')
	outputs.file 'assets/fonts/iconfont.ttf'
	outputs.file 'assets/fonts/iconfont.svg'
	outputs.file 'assets/fonts/iconfont.woff'
	outputs.file 'assets/fonts/iconfont.eot'
	outputs.file '_sass/_iconfont.scss'
	outputs.file 'sources/iconfont/iconfont-preview.html'
	logging.captureStandardOutput LogLevel.INFO
	commandLine Os.isFamily(Os.FAMILY_WINDOWS)? 'fontcustom.bat' : 'fontcustom', 'compile'
}

def style = 'styles_feeling_responsive'
def slow = file("assets/css/${style}.scss")
def ignored = file("assets/css/_${style}.scss")
def fast = "assets/css/${style}.css"
def fastSource = file("_site/" + fast)
task fastStyleCopyCachedCSS(type: Copy) {
	afterEvaluate { tasks.clean.mustRunAfter fastStyleCopyCachedCSS }

	from fastSource
	into 'assets/css'
	onlyIf { 
		if (!fastSource.exists()) {
			logger.warn("There's no rendered CSS file: ${fastSource}")
			return false;
		}
		return true
	}
}
task fastStyle(dependsOn: fastStyleCopyCachedCSS) {
	group = "Efficiency"
	description = "Uses generated CSS from _site instead of compiling from _sass."
	afterEvaluate { tasks.build.mustRunAfter fastStyle }
	afterEvaluate { tasks.serve.mustRunAfter fastStyle }

	onlyIf { fastStyleCopyCachedCSS.state.didWork || fastStyleCopyCachedCSS.state.skipMessage == 'UP-TO-DATE' }
	doLast {
		if (slow.exists() && ignored.exists() && slow.text == ignored.text) { ignored.delete(); }
		if (!slow.renameTo(ignored)) { throw new IOException("Cannot rename ${slow} to ${ignored}.") }
	}
	outputs.upToDateWhen { !slow.exists() && ignored.exists() }
}
task slowStyleRemoveCachedCSS(type: Delete) {
	delete fast
	onlyIf { slow.exists() || ignored.exists() }
}
task slowStyle(dependsOn: slowStyleRemoveCachedCSS) {
	group = "Efficiency"
	description = "Generates CSS from _sass."
	afterEvaluate { tasks.build.mustRunAfter slowStyle }
	afterEvaluate { tasks.serve.mustRunAfter slowStyle }

	doLast { if (!ignored.renameTo(slow)) { throw new IOException("Cannot rename ${ignored} to ${slow}.") } }
	outputs.upToDateWhen { !ignored.exists() && slow.exists() }
}

project.afterEvaluate {
	task fastDev(dependsOn: [fastStyle, serve, dev, skip]) {
		group = "Efficiency"
		description = "Daily development task to run in browser for editing content."
	}
	task fastDevStyle(dependsOn: [slowStyle, serve, dev, skip]) {
		group = "Efficiency"
		description = "Daily development task to run in browser for editing theme."
	}
	task preCommit(dependsOn: [slowStyle, clean, jobs, build]) {
		group = "Efficiency"
		description = "Task to run before commiting to version control."
	}
	task preCommitServe(dependsOn: [slowStyle, clean, jobs, serve, local]) {
		group = "Efficiency"
		description = "Task to run before commiting to version control."
	}
	task rebuild(dependsOn: [slowStyle, clean, jobs, font, build, local]) {
		group = "Efficiency"
		description = "Rebuild the whole site from scratch."
	}
}

task clean(type: Delete) {
	group = Jekyll.GROUP
	description = "Remove files generated by jekyll build"
	delete '.sass-cache', '_site'
}
task build(type: Jekyll) {
	description = "Runs jekyll build, use tasks in ${JekyllSetup.GROUP} group to change behavior"
	jekyllTask 'build'
	mustRunAfter clean
}
task serve(type: Jekyll) {
	description = "Start jekyll in serve mode, use tasks in ${JekyllSetup.GROUP} group to change behavior"
	jekyllTask 'serve'
	mustRunAfter clean
	outputs.upToDateWhen { false }
}

task local(type: JekyllSetup) {
	description = "Use _config_local.yml overrides"
	action = {
		it.config '_config_local.yml'
	}
}
task dev(type: JekyllSetup, dependsOn: local) {
	description = "Use _config_dev.yml overrides and sets JEKYLL_ENV to development"
	action = {
		it.config '_config_dev.yml';
		it.environment 'JEKYLL_ENV', 'development'
	}
}
task noskip(type: JekyllSetup) {
	description = "Remove --skip-initial-build from serve command (default is ${build.skip? "added" : "removed"})";
	action = { it.skip = false }
}
task skip(type: JekyllSetup) {
	description = "Add --skip-initial-build to serve command (default is ${build.skip? "added" : "removed"})";
	action = { it.skip = true }
	noskip.mustRunAfter skip
}
task notrace(type: JekyllSetup) {
	description = "Remove --trace argument from jekyll (default is ${build.trace? "added" : "removed"})";
	action = { it.trace = false }
}
task trace(type: JekyllSetup) {
	description = "Add --trace argument to jekyll (default is ${build.trace? "added" : "removed"})";
	action = { it.trace = true }
	notrace.mustRunAfter trace
}
task noverbose(type: JekyllSetup) {
	description = "Remove --trace argument from jekyll (default is ${build.verbose? "added" : "removed"})";
	action = { it.verbose = false }
}
task verbose(type: JekyllSetup) {
	description = "Add --trace argument to jekyll (default is ${build.verbose? "added" : "removed"})";
	action = { it.verbose = true }
	noverbose.mustRunAfter verbose
}

class JekyllSetup extends DefaultTask {
	static final GROUP = "Jekyll Param"
	Closure action

	JekyllSetup() {
		group = GROUP
		project.afterEvaluate {
			project.tasks.withType(Jekyll) { it.mustRunAfter this }
		}
	}

	@TaskAction
	public void setup() {
		project.tasks.withType(Jekyll).all(action)
	}
}

class Jekyll extends Exec {
	static final GROUP = "Jekyll"
	boolean trace = true
	boolean verbose = false
	boolean skip = false
	String jekyllTask
	private final List<String> configs = ['_config.yml']
	
	Jekyll() {
		group = GROUP
		def excludes = new org.yaml.snakeyaml.Yaml().load(new File(project.rootDir, '_config.yml').text).exclude
		def tree = project.fileTree(dir: project.rootDir)
		excludes.each { tree.exclude it }
		configs.each { tree.include it }
		inputs.files tree
		outputs.dir new File(project.rootDir, '_site')
		onlyIf { jekyllTask }

		if (System.env.JEKYLL_ENV?.trim()) {
			environment 'JEKYLL_ENV', System.env.JEKYLL_ENV?.trim()
		} else {
			environment 'JEKYLL_ENV', 'production'
		}
	}

	@Override protected void exec() {
		workingDir = project.file(unsubst(workingDir.path))
		commandLine ([Os.isFamily(Os.FAMILY_WINDOWS)? 'bundle.bat' : 'bundle',
			'exec',
			'jekyll',
			jekyllTask,
			configs.size? '--config' : '',
			configs.join(','),
			trace? '--trace' : '',
			verbose? '--verbose' : '',
			jekyllTask == 'serve' && skip? '--skip-initial-build': ''] + args)
		super.exec();
	}

	void config(String file) {
		configs.add file
		inputs.file file
	}

	private static String unsubst(String path) {
		if (!Os.isFamily(Os.FAMILY_WINDOWS)) return path
		def subst = 'subst'.execute()
		def substs = [:]
		subst.text.eachLine {
			substs[it[0..1]] = it.substring('X:\\: => '.size(), it.size())
		}
		if (subst.exitValue()) return path
		while(path[0..1] in substs) {
			path = substs[path[0..1]] + path.substring(2)
		}
		return path
	}
}
